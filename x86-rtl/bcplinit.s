# -- Standard BCPL library functions that need to be coded in assembler --------

    .section        .text.bcplmain,"ax",@progbits
#
# On entry, the shell has set up the stack to look like this:
#
#        rsp:    number of arguments (argc)
#         +8:    address of first 0-terminated argument (argv[0])
#        +16:    address of second 0-terminated argument (argv[1])
#                ...
# rsp+8*argc:    null pointer terminating the arguments
# rsp+16*argc:   address of first 0-terminated environment string of the form NAME=VALUE
#                 ...
#                 null pointer terminating the arguments

        .global _start
        .extern blib.bcplmain
_start:
        endbr64
        xorq   %rbp, %rbp            # Mark deepest stack frame
        popq   %rdi                  # argc
        movq   %rsp, %rsi            # argv
        leaq   8(%rsp,%rdi,8), %rcx  # environment
        callq  blib.bcplmain         # Will return with exit status in %rax
        movq   %rax, %rdi
        movq   %rax, 60
        syscall

#      RES := APTOVEC(F, N)
#
#      This function applies the procedure F to two arguments V
#      and N where V is a vector of size N. The result is the
#      value (if any) returned by the call of F. A

__aptovec:
        pushq   %rbp                # Save the caller's frame pointer
        movq    %rsp, %rbp          # and the stack pointer on entry
        movq    %rdi, %rax          # F, entry point of bcpl routine to be called
        movq    %rsp, %rdi          # We'll calculate the new sp/vector address here
        leaq    15(,%rsi,8), %rcx   # Convert the N in %rsi from bcplwords to bytes and
        andq    $-16, %rcx          # align to 16 bytes by adding 15 and clearing bits 0..3
        subq    %rcx, %rdi          # Subtract from the old stack top to push the
        movq    %rdi, %rsp          # new vector onto the stack
        shrq    $3, %rdi            # convert this to the vector's bcpl word address
        callq   *%rax               # Call the routine we were given with this
        movq    %rbp, %rsp          # Pop the vector off the stack
        popq    %rbp                # Restore the caller's frame pointer
        retq

#
# abort is a handy way for the following code to call the BLIB abort()
# function in global 28. %rdi is to hold the abort code.
abort:
    movq    $__bcpl_global_vector+8*28, %rax
    jmp     *(%rax)

# memset is expected by the code generated by llvm for packstring to clear the
# unused elements of the output vector.
#
#  %rdi - machine address of the start of the buffer
#  %rsi - byte to be used to fill the buffer
#  %rdx - size of the buffer
#  %rax - holds input %rdi on exit

        .global memset
memset:
        movq   %rdi, %rax          # Value to return on exit
#
# Until we are aligned on a bcplword boundary, fill a byte at a time
#
unaligned:
        test   $7, %rdi            # Bottom 3 bits clear if aligned
        jz     aligned
        movb   %sil, (%rdi)        # Copying a byte at a time
        inc    %rdi
        dec    %rdx
        jnz    unaligned
        jz     done
aligned:
        movzx  %dil, %rdi          # Zero-extend byte to register width
        movq $0x0101010101010101, %r8
        imul   %r8, %rdi           # Multiply by magic constant
        cmpq   $8, %rdx            # Can we copy another bcplword-full
        jb     fewer_than_8
        movq   %rsi, (%rdi)
        addq   $8, %rdi
        subq   $8, %rdx
        cmpq   $8, %rdx
        jae    aligned

        testq  %rdx, %rdx
        jz     done
fewer_than_8:
        movb   %sil, (%rdi)
        incq   %rdi
        decq   %rdx
        jnz    fewer_than_8
done:
        retq                       # We set up %rax on entry


#
#     RES := MULDIV(A,B,C)
#
# This function calculates (A*B)/C, holding the intermediate product (A*B)
# as a double length integer. If the result does not fit in a normal integer
# the action of MULDIV is undefined. The remainder from the division is left
# in global variable RESULT2.
#
__muldiv:

# Save divisor in a different register. It's a caller-saved register, we
# don't need to preserve it. %rdx will be overwritten by the multiply.
       movq    %rdx, %r11          # divisor

       # Check for division by zero
       testq   %r11, %r11
       jz      zero_divide

# Perform multiplication a * b leaving the 128-bit result in %rdx:%rax
       movq    %rdi, %rax          # %rax = a
       imulq   %rsi                # %rdx:%rax = a * b

# Divide by c leaving the 64-bit quotient in %rax and the remainder in %rdx
       idivq   %r11                # %rax = quotient, %rdx = remainder
       jmp     return

# Division by zero returns 0 rem 0
zero_divide:
       xorq    %rax, %rax
       xorq    %rdx, %rdx

return:
       movq    $__bcpl_global_vector, %rdi
       movq    %rdx, 10*8(%rdi)    # Store remainder in global 10, result
       retq


# -- P := LEVEL() --------------------------------------------------------------
#
#   This function gives a representation of the current procedure activation
#   level for use with LONGJUMP
#
__level:
    endbr64
    movq    $__bcpl_levelstate, %rdi
1:
    movq    (%rdi), %rsi           # Entry key
    cmpq    %rsi, %rsp             # If sp >= si, stale or unused entry
    jge     2f
    addq    $7*8, %rdi
    jmp     1b

2:
    testq   %rsi,%rsi              # If zero, we've run out of table
    jnz     3f
    movq    $105, %rdi             # ABORT_TOOMANYLEVELS
    jmp     abort

3:
    movq    %rsp, %rax             # Preserve caller's sp and set up as result
    leaq    56(%rdi), %rsp         # Make the table entry the top of stack
    push    %r15                   # Save the non-volatiles into the entry
    push    %r14
    push    %r13
    push    %r12
    push    %rbx
    push    %rbp
    push    %rax                   # First quad in entry is the SP
    movq    %rax, %rsp             # Restore the SP
    retq


# -- LONGJUMP(P, L) ------------------------------------------------------------
#
#   This routine causes a non-local jump to the label L at the activation
#   level P
#
__longjump:
    endbr64
    movq    $__bcpl_levelstate, %rdx    # Start of saved state table
1:
    movq    (%rdx), %rcx           # The entry's SP
    testq    %rcx, %rcx            # Zero means we've run out of entries
    jz      3f
    cmpq    %rcx, %rdi             # Is it the caller-specified SP?
    je      2f                     # If so, we have found the entry
    addq    $7*8, %rdx
    jmp     1b
2:
    movq    %rdx, %rsp             # Treat the state as a stack and pop to
    popq    %rax                   # restore the volatile registers. The
    popq    %rbp                   # first item is the SP but we can't set
    popq    %rbx                   # that yet as we're using it to pop the
    popq    %r12                   # rest. Keep it in AX until the end.
    popq    %r13
    popq    %r14
    popq    %r15
    movq    %rax, %rsp             # SP as it was on call to level()
    addq    $8, %rsp               # so drop level()'s return address
    jmp     *%rsi                  # branch to the label

3:
    movq    $106, %rdi             # ABORT_NOSUCHLEVEL
    jmp     abort

__opsys:
    endbr64
    movq    %rdi,%rax
    movq    %rsi,%rdi
    movq    %rdx,%rsi
    movq    %rcx,%rdx
    movq    %r8,%r10
    movq    %r9,%r8
    movq    0x8(%rsp),%r9
    syscall
    retq

# -- The standard BCPL Global Vector -------------------------------------------
#
# This corresponds to the values in cintcode/g/libhdr.h

    .equ MAXGLOBALS,1024
    .section BCPLGVEC,"aw",@progbits
    .global __bcpl_global_vector

# Set up the global vector by initialising each cell to zero and defining a
# weak symbol __bcpl_gvn for global n. The code generator will create an alias
# with this name for each ENTRY name and so the linker will resolve it as the 
# address of the entry. In order to use the assembler's \@ mechanism within 
# the .rept we must wrap our content in a .macro:

    .macro GLOBAL_INIT
     .quad __bcpl_gv\@
     .weak __bcpl_gv\@
     .endm
 
 # Then define each of our 512 globals

        .data
        .align     8

 __bcpl_global_vector:
        .rept MAXGLOBALS
        GLOBAL_INIT
        .endr
        .type __bcpl_global_vector, @object
        .size __bcpl_global_vector, MAXGLOBALS*8

# Initialise our global vector with the entries for the standard library
# by defining the Gn to match the entry point of each routine.

    .macro GLOBAL gn, symbol
    .set __bcpl_gv\gn,\symbol
    .endm

    GLOBAL   0, MAXGLOBALS # 0      globsize
#   .quad 0                # 1      START
#    GLOBAL   2, __stop     # 2      STOP is called by the FINISH O-code operator
#   .quad 0                # 3      (sys)
#   .quad 0                # 4      (clihook)
    GLOBAL   5, __muldiv
#   .quad 0                # 6      (changeco)
#   .quad 0                # 7      (currco)
#   .quad 0                # 8      (colist)
#   .quad 0                # 9      (rootnode)
#   .quad 0                # 10     RESULT2
#   .quad 0                # 11     (tempval)
#   .quad 0                # 12     CIS
#   .quad 0                # 13     COS
#   .quad 0                # 14     (currentdir)
    GLOBAL  15, __level
    GLOBAL  16, __longjump
#   .quad 0                # 17     (createco)
#   .quad 0                # 18     (deleteco)
#   .quad 0                # 19     (callco)
#   .quad 0                # 20     (cowait)
#   .quad 0                # 21     (resumeco)
#   .quad 0                # 22     (initco)
#   .quad 0                # 23     (startco)
#   .quad 0                # 24     (globin)
#   .quad 0                # 25     (globin)
#   .quad 0                # 26     (rdargs2)
#   .quad 0                # 27     (globin)
#   .quad 0                # 28     (abort)
#   .quad 0                # 29     (sysabort)
#    GLOBAL  30, __packstring
#    GLOBAL  31, __unpackstring
#   .quad 0                # 32     (getword)
#   .quad 0                # 33     (putword)
#   .quad 0                # 34     RANDNO
#   .quad 0                # 35     (setseed)
#   .quad 0                # 36     (sardch)
#   .quad 0                # 37
#    GLOBAL  38, __rdch
#   .quad 0                # 39
#    GLOBAL  40, __unrdch
#    GLOBAL  41, __wrch
#   .quad 0                # 42
#   .quad 0                # 43
#   .quad 0                # 44
    GLOBAL   6, __aptovec
    GLOBAL  32, __opsys
#   .quad 0                # 46
#   .quad 0                # 47
#   .quad 0                # 48     findinput
#   .quad 0                # 49     findoutput
#   .quad 0                # 50
#   .quad 0                # 51
#    GLOBAL  52, __findstream
#   .quad 0                # 53
#   .quad 0                # 54
#   .quad 0                # 55
#    GLOBAL  56, __selectinput
#    GLOBAL  57, __selectoutput
#    GLOBAL  58, __input
#    GLOBAL  59, __output
#   .quad 0                # 60     endread
#   .quad 0                # 61     endwrite
#    GLOBAL  62, __endstream
#   .quad 0                # 63
#   .quad 0                # 64
#    GLOBAL  ?, __rewind
#   .quad 0                # 66
#   .quad 0                # 67
#   .quad 0                # 68
#   .quad 0                # 69
#   .quad 0                # 70
#   .quad 0                # 71
#   .quad 0                # 72
#    GLOBAL  73, __writeflt
#   .quad 0                # 73
#   .quad 0                # 74
#   .quad 0                # 75
#   .quad 0                # 76
#   .quad 0                # 77
#   .quad 0                # 78
#   .quad 0                # 79
#   .quad 0                # 80
#   .quad 0                # 81
#   .quad 0                # 82
#   .quad 0                # 83
#   .quad 0                # 84
#   .quad 0                # 85
#   .quad 0                # 86
#   .quad 0                # 87
#   .quad 0                # 88
#   .quad 0                # 89
#   .quad 0                # 90
#   .quad 0                # 91
#   .quad 0                # 92
#   .quad 0                # 93
#   .quad 0                # 94
#   .quad 0                # 95
#   .quad 0                # 96
#   .quad 0                # 97
#   .quad 0                # 98
#   .quad 0                # 99
#   .quad 0                # 100   
#   .quad 0                # 101   
#   .quad 0                # 102   
#   .quad 0                # 103   
#   .quad 0                # 104   
#   .quad 0                # 105   
#   .quad 0                # 106   
#   .quad 0                # 107   
#   .quad 0                # 108   
#   .quad 0                # 109   
#   .quad 0                # 110  
#   .quad 0                # 111  
#   .quad 0                # 112  
#   .quad 0                # 113  
#   .quad 0                # 114  
#   .quad 0                # 115  
#   .quad 0                # 116  
#   .quad 0                # 117  
#   .quad 0                # 118  
#   .quad 0                # 119
#   .quad 0                # 120
#   .quad 0                # 121
#   .quad 0                # 122
#   .quad 0                # 123
#   .quad 0                # 124
#   .quad 0                # 125
#   .quad 0                # 126
#   .quad 0                # 127    RANDSEED


# Each space has room to save the non-volatile state of the program when LEVEL()
# is called. We assume that RSP can be used as a key to look up the state and
# that RSP is never zero.
#
# rsp rbp  rbx  r12  r13  r14  r15
#
# As we have a falling stack, any entry with an RSP that is lower that the
# current RSP will be stale or never used

    .type __bcpl_levelstate, @object
    .size __bcpl_levelstate, 128*8
__bcpl_levelstate:
    .rept 8
    .quad 1, 0, 0, 0, 0, 0, 0      # each state has SP lower than any true SP
    .endr
    .quad 0                        # but not zero as that terminates the table
